class Solution {
public:
    int search(vector<int>& nums, int target) {
        int lo = 0, hi = nums.size() - 1;
        while (lo < hi) {
            int mid = (lo + hi) / 2;
            if ((nums[0] > target) ^ (nums[0] > nums[mid]) ^ (target > nums[mid]))
                lo = mid + 1;
            else
                hi = mid;
        }
        return lo == hi && nums[lo] == target ? lo : -1;
    }
};
/*来解释一下这种巧妙的解法 ，观察题目发现  所谓的旋转  其实就是将一个升序的数组一刀切开，变成两个升序数组
那么要进行二分 就分析究竟有多少种情况  我们实际上有这么几种数组排列情况
4 5 6 7 1 2 3
这种情况 二分法的mid值不会导致什么影响 如果target在任何一边 都可以继续二分
5 6 7 1 2 3 4
这种情况 mid值小于起始值 说明 我们要考虑target的位置 如果他同时大于mid和low
那么二分将在左半部分继续进行 否则去右半部分
7 1 2 3 4 5 6 
和上一种情况类似 但是这次是target同时小于mid和low，同样 此时应该从左半部分继续
二分

而除了上述的三种情况以外 应都从右半部开始二分  所以需要将这三种情况进行列举
复杂的办法就是一一列举
简单的方法就是使用异或运算 将三个分条件列出 只有两个条件成立的时候  异或才为真
(nums[0] <= target)， (target <= nums[i]) ，(nums[i] < nums[0])，现在我们想知道这三项中有哪两项为真（明显这三项不可能均为真或均为假（因为这三项可能已经包含了所有情况））

所以我们现在只需要区别出这三项中有两项为真还是只有一项为真。

使用 “异或” 操作可以轻松的得到上述结果（两项为真时异或结果为假，一项为真时异或结果为真，可以画真值表进行验证）

之后我们通过二分查找不断做小 target 可能位于的区间直到 low==high，此时如果 nums[low]==target 则找到了，如果不等则说明该数组里没有此项。
